# Use a Docker image that includes Python and Wine (e.g., a custom or readily available Wine/PyInstaller image)
# This example uses a standard Python image and installs Wine, or you can use a pre-built image like:
# image: cdgriffith/pyinstaller-wine-builder
image: python:3.10-slim

# Global variables
variables:
  APP_NAME: "Toliss Cabin Announcements-Test.exe"
  MAIN_SCRIPT: "cabinselection.py"
  # Set architecture for Wine to target 32-bit Windows executables (common default)
  WINEARCH: "win32" 

# --- Stages Definition ---
stages:
  - build

# ----------------------------------
# Windows PyInstaller Build Job
# ----------------------------------
build_windows_executable:
  stage: build
  # Only run on Git tags (releases)
  rules:
    - if: $CI_COMMIT_TAG
      when: always

  script:
    - echo "Starting Windows PyInstaller build for tag $CI_COMMIT_TAG using Wine..."

    # 1. Install Dependencies for Wine (Standard for Debian/Ubuntu based images)
    # Update and install Wine. This can take a few minutes.
    - apt-get update && apt-get install -y --no-install-recommends wine

    # 2. Configure Python Dependencies (Run these under Wine)
    # The 'wine python -m pip' structure ensures that pip runs inside the emulated Windows environment.
    - wine python -m pip install --upgrade pip
    - wine python -m pip install pyinstaller
    - wine python -m pip install -r requirements.txt
    
    # 3. Run PyInstaller
    # PyInstaller is executed via Wine. It automatically targets the architecture
    # defined by the Wine environment (defaulting to Windows).
    # The output executable will be named 'my_application.exe'
    - wine pyinstaller --onefile --name $APP_NAME --clean $MAIN_SCRIPT

    # 4. Verification
    - echo "Verifying build output..."
    # The output is still placed in the 'dist' directory
    - ls -l dist/

    # 5. Cleanup
    - rm -rf build/
    - rm -f $APP_NAME.spec

    - echo "Windows build completed successfully. Executable is $APP_NAME.exe"

  # Define the artifacts to be saved
  artifacts:
    name: "$APP_NAME"
    paths:
      - dist/
    when: on_success
    # Artifacts will be kept indefinitely (as requested previously)